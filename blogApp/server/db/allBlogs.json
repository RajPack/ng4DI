[{"id":1,"title":"Angular Rocks","content":"Angular is a platform that makes it easy to build applications with the web. Angular combines declarative templates, dependency injection, end to end tooling, and integrated best practices to solve development challenges. \n    \n    Angular empowers developers to build applications that live on the web, mobile, or the desktop","author":"Google Angular Team, Raj","thumbsUp":39,"thumbsDown":1},{"id":2,"title":"Angular Architecture","content":"Angular is a framework for building client applications in HTML and either JavaScript or a language like TypeScript that compiles to JavaScript.   \n    The framework consists of several libraries, some of them core and some optional.  You write Angular applications by composing HTML templates with Angularized markup, writing component classes to manage those templates, adding application logic in services, and boxing components and services in modules. \n    \n    Then you launch the app by bootstrapping the root module. Angular takes over, presenting your application content in a browser and responding to user interactions according to the instructions you provided.","author":"Google Angular Team","thumbsUp":22,"thumbsDown":3},{"id":3,"title":"Dependency Injection (DI)","content":"Dependency injection is an important application design pattern. It's used so widely that almost everyone just calls it DI.\n\n    Angular has its own dependency injection framework, and you really can't build an Angular application without it.\n    \n    This page covers what DI is and why it's useful.\n    \n    When you've learned the general pattern, you're ready to turn to the Angular Dependency Injection guide to see how it works in an Angular app.","author":"Google Angular Team, raj","thumbsUp":51,"thumbsDown":6},{"id":4,"title":"Observables","content":"Observables provide support for passing messages between publishers and subscribers in your application. Observables offer significant benefits over other techniques for event handling, asynchronous programming, and handling multiple values.    Observables are declarative—that is, you define a function for publishing values, but it is not executed until a consumer subscribes to it. The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.   An observable can deliver multiple values of any type—literals, messages, or events, depending on the context. \n    \n    The API for receiving values is the same whether the values are delivered synchronously or asynchronously. Because setup and teardown logic are both handled by the observable, your application code only needs to worry about subscribing to consume values, and when done, unsubscribing. Whether the stream was keystrokes, an HTTP response, or an interval timer, the interface for listening to values and stopping listening is the same","author":"Google Angular Team","thumbsUp":34,"thumbsDown":1},{"id":5,"title":"Dynamic Forms in Angular","content":"Building handcrafted forms can be costly and time-consuming, especially if you need a great number of them, they're similar to each other, and they change frequently to meet rapidly changing business and regulatory requirements.\n\n    It may be more economical to create the forms dynamically, based on metadata that describes the business object model.\n    \n    This cookbook shows you how to use formGroup to dynamically render a simple form with different control types and validation. It's a primitive start. It might evolve to support a much richer variety of questions, more graceful rendering, and superior user experience. All such greatness has humble beginnings.\n    \n    The example in this cookbook is a dynamic form to build an online application experience for heroes seeking employment. The agency is constantly tinkering with the application process. You can create the forms on the fly without changing the application code. ","author":"Google Angular Team","thumbsUp":12,"thumbsDown":1},{"title":"Converting A Subject To An Observable Using RxJS In Angular 2","content":"In Angular 2, you can use the Rx.Subject class to create the source of an observable sequence. But, you never want to return an Rx.Subject instance to the calling context. \n\nDoing so would be somewhat akin to returning a Deferred object rather than a promise; and, it would leave the Subject open to unanticipated and corrupting usage. As such, when exposing a Subject, you'll probably want to convert it to an Observable first.","author":"Ben","id":1522323869204,"thumbsDown":0,"thumbsUp":1},{"title":"Redux in Angular","content":"Redux is a predictable state container for JavaScript apps which makes it possible to use a centralized state management in your application. So what exactly is meant by state and centralized state management? Simply, you can think of state as just data you use in your application. So a centralized state is just data you’re using by more than one component (application level state).\n\nIn the following you’ll get an overview of Redux building blocks and learn to apply Redux in your Angular application by building a sample application step-by-step.\n\nBuilding Blocks of Redux\nThe Redux website can be found at http://redux.js.org/. Redux can be used with any modern JavaScript-based web frameworks. Before starting to build our Angular Redux sample application let’s first clarify the core concept of Redux.\n\nRedux organizes your application state in the store, a single data structure in your application. The components of your application read the state of the application from the store. The store is never mutated directly. Instead a action is dispatched to a reducer function. The reducer function creates a new application state by combining the old state and the mutations defined by the action.\n\nLet’s explore the building blocks of Redux one by one:\n\nStore\nThe store is a single JS object. To create a store you simple need to a add a TypeScript file to the project and declare a new interface type which contains all the properties you’d like to keep in the store.\n\nActions\nActions are plain JS objects that represent something that has happened. Can be compared to events.\n\nReducers\nA reducer is a function that specifies how the state changes in response to an action.\n\nWhat’s important to understand is the fact that a reducer function does not modify the state. It always returns a new state object with the modifications included.\n\nA reducer function must always be a pure function. That means that the function must ensure that if the same input is given always the same output is produced.\n\n","author":"Raj","id":1522344690197,"thumbsDown":0,"thumbsUp":1}]